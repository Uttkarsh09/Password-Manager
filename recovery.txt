{
    "_meta": {
        "hash": {
            "sha256": "f3091d6e2998125ef84af8d9c5760fedd188da0e500d67bd52b6d5ed598b2980"
        },
        "pipfile-spec": 6,
        "requires": {
            "python_version": "3.9"
        },
        "sources": [
            {
                "name": "pypi",
                "url": "https://pypi.org/simple",
                "verify_ssl": true
            }
        ]
    },
    "default": {
        "caugetch": {
            "hashes": [
                "sha256:6f6ddb3b928fa272071b02aabb3342941cd99992f27413ba8c189eb4dc3e33b0",
                "sha256:ee743dcbb513409cd24cfc42435418073683ba2f4bb7ee9f8440088a47d59277"
            ],
            "markers": "python_version >= '3.6'",
            "version": "==0.0.1"
        },
        "clipboard": {
            "hashes": [
                "sha256:a72a78e9c9bf68da1c3f29ee022417d13ec9e3824b511559fd2b702b1dd5b817"
            ],
            "version": "==0.0.4"
        },
        "colorama": {
            "hashes": [
                "sha256:5941b2b48a20143d2267e95b1c2a7603ce057ee39fd88e7329b0c292aa16869b",
                "sha256:9f47eda37229f68eee03b24b9748937c7dc3868f906e8ba69fbcbdd3bc5dc3e2"
            ],
            "markers": "python_version >= '2.7' and python_version not in '3.0, 3.1, 3.2, 3.3, 3.4'",
            "version": "==0.4.4"
        },
        "examples": {
            "hashes": [
                "sha256:372fefd15d5a17bda3b003cf26edbc2d29632bc63f29c816b55ed33dcccb3e65",
                "sha256:f29ba443f158bb47913ac21f098306a9749ed459a2290540ff1f86baac074597"
            ],
            "index": "pypi",
            "version": "==1.0.2"
        },
        "getpass4": {
            "hashes": [
                "sha256:86b88c9120a6ff9ce16c309c9962af22a419d3b2672c56085340a172bf5391b1",
                "sha256:a3095624604e7f526a4b73aa6173059cb4115a0a381427213bef14a0a4aac683"
            ],
            "index": "pypi",
            "version": "==0.0.8"
        },
        "prompt": {
            "hashes": [
                "sha256:8a7694b88f8c65188a983315e72582bf42fcc251b97042be1d2a2ad1aa0ebe0e",
                "sha256:98527de8dc3f0aa29669a39fbffeaf578ba6654dc836f737b6a5c6f9279002b7"
            ],
            "index": "pypi",
            "version": "==0.4.1"
        },
        "prompt-toolkit": {
            "hashes": [
                "sha256:7281b5199235adaef6980942840c43753e4ab20dfe41338da634fb41c194f9d8",
                "sha256:82c7f8e07d7a0411ff5367a5a8ff520f0112b9179f3e599ee8ad2ad9b943d911",
                "sha256:cc66413b1b4b17021675d9f2d15d57e640b06ddfd99bb724c73484126d22622f"
            ],
            "version": "==1.0.14"
        },
        "pycrypto": {
            "hashes": [
                "sha256:f2ce1e989b272cfcb677616763e0a2e7ec659effa67a88aa92b3a65528f60a3c"
            ],
            "version": "==2.6.1"
        },
        "pycryptodome": {
            "hashes": [
                "sha256:014c758af7fa38cab85b357a496b76f4fc9dda1f731eb28358d66fef7ad4a3e1",
                "sha256:06162fcfed2f9deee8383fd59eaeabc7b7ffc3af50d3fad4000032deb8f700b0",
                "sha256:0ca7a6b4fc1f9fafe990b95c8cda89099797e2cfbf40e55607f2f2f5a3355dcb",
                "sha256:2a4bcc8a9977fee0979079cd33a9e9f0d3ddba5660d35ffe874cf84f1dd399d2",
                "sha256:3c7ed5b07274535979c730daf5817db5e983ea80b04c22579eee8da4ca3ae4f8",
                "sha256:4169ed515742425ff21e4bd3fabbb6994ffb64434472fb72230019bdfa36b939",
                "sha256:428096bbf7a77e207f418dfd4d7c284df8ade81d2dc80f010e92753a3e406ad0",
                "sha256:4ce6b09547bf2c7cede3a017f79502eaed3e819c13cdb3cb357aea1b004e4cc6",
                "sha256:53989477044be41fa4a63da09d5038c2a34b2f4554cfea2e3933b17186ee9e19",
                "sha256:621a90147a5e255fdc2a0fec2d56626b76b5d72ea9e60164c9a5a8976d45b0c9",
                "sha256:6db1f9fa1f52226621905f004278ce7bd90c8f5363ffd5d7ab3755363d98549a",
                "sha256:6eda8a3157c91ba60b26a07bedd6c44ab8bda6cd79b6b5ea9744ba62c39b7b1e",
                "sha256:75e78360d1dd6d02eb288fd8275bb4d147d6e3f5337935c096d11dba1fa84748",
                "sha256:7ff701fc283412e651eaab4319b3cd4eaa0827e94569cd37ee9075d5c05fe655",
                "sha256:8f3a60926be78422e662b0d0b18351b426ce27657101c8a50bad80300de6a701",
                "sha256:a843350d08c3d22f6c09c2f17f020d8dcfa59496165d7425a3fba0045543dda7",
                "sha256:ae29fcd56152f417bfba50a36a56a7a5f9fb74ff80bab98704cac704de6568ab",
                "sha256:ae31cb874f6f0cedbed457c6374e7e54d7ed45c1a4e11a65a9c80968da90a650",
                "sha256:b33c9b3d1327d821e28e9cc3a6512c14f8b17570ddb4cfb9a52247ed0fcc5d8b",
                "sha256:b59bf823cfafde8ef1105d8984f26d1694dff165adb7198b12e3e068d7999b15",
                "sha256:bc3c61ff92efdcc14af4a7b81da71d849c9acee51d8fd8ac9841a7620140d6c6",
                "sha256:ce81b9c6aaa0f920e2ab05eb2b9f4ccd102e3016b2f37125593b16a83a4b0cc2",
                "sha256:d7e5f6f692421e5219aa3b545eb0cffd832cd589a4b9dcd4a5eb4260e2c0d68a",
                "sha256:da796e9221dda61a0019d01742337eb8a322de8598b678a4344ca0a436380315",
                "sha256:ead516e03dfe062aefeafe4a29445a6449b0fc43bc8cb30194b2754917a63798",
                "sha256:ed45ef92d21db33685b789de2c015e9d9a18a74760a8df1fc152faee88cdf741",
                "sha256:f19edd42368e9057c39492947bb99570dc927123e210008f2af7cf9b505c6892",
                "sha256:f9bad2220b80b4ed74f089db012ab5ab5419143a33fad6c8aedcc2a9341eac70",
                "sha256:fce7e22d96030b35345637c563246c24d4513bd3b413e1c40293114837ab8912",
                "sha256:ffd0cac13ff41f2d15ed39dc6ba1d2ad88dd2905d656c33d8235852f5d6151fd"
            ],
            "index": "pypi",
            "version": "==3.11.0"
        },
        "pydantic": {
            "hashes": [
                "sha256:021ea0e4133e8c824775a0cfe098677acf6fa5a3cbf9206a376eed3fc09302cd",
                "sha256:05ddfd37c1720c392f4e0d43c484217b7521558302e7069ce8d318438d297739",
                "sha256:05ef5246a7ffd2ce12a619cbb29f3307b7c4509307b1b49f456657b43529dc6f",
                "sha256:10e5622224245941efc193ad1d159887872776df7a8fd592ed746aa25d071840",
                "sha256:18b5ea242dd3e62dbf89b2b0ec9ba6c7b5abaf6af85b95a97b00279f65845a23",
                "sha256:234a6c19f1c14e25e362cb05c68afb7f183eb931dd3cd4605eafff055ebbf287",
                "sha256:244ad78eeb388a43b0c927e74d3af78008e944074b7d0f4f696ddd5b2af43c62",
                "sha256:26464e57ccaafe72b7ad156fdaa4e9b9ef051f69e175dbbb463283000c05ab7b",
                "sha256:41b542c0b3c42dc17da70554bc6f38cbc30d7066d2c2815a94499b5684582ecb",
                "sha256:4a03cbbe743e9c7247ceae6f0d8898f7a64bb65800a45cbdc52d65e370570820",
                "sha256:4be75bebf676a5f0f87937c6ddb061fa39cbea067240d98e298508c1bda6f3f3",
                "sha256:54cd5121383f4a461ff7644c7ca20c0419d58052db70d8791eacbbe31528916b",
                "sha256:589eb6cd6361e8ac341db97602eb7f354551482368a37f4fd086c0733548308e",
                "sha256:8621559dcf5afacf0069ed194278f35c255dc1a1385c28b32dd6c110fd6531b3",
                "sha256:8b223557f9510cf0bfd8b01316bf6dd281cf41826607eada99662f5e4963f316",
                "sha256:99a9fc39470010c45c161a1dc584997f1feb13f689ecf645f59bb4ba623e586b",
                "sha256:a7c6002203fe2c5a1b5cbb141bb85060cbff88c2d78eccbc72d97eb7022c43e4",
                "sha256:a83db7205f60c6a86f2c44a61791d993dff4b73135df1973ecd9eed5ea0bda20",
                "sha256:ac8eed4ca3bd3aadc58a13c2aa93cd8a884bcf21cb019f8cfecaae3b6ce3746e",
                "sha256:e710876437bc07bd414ff453ac8ec63d219e7690128d925c6e82889d674bb505",
                "sha256:ea5cb40a3b23b3265f6325727ddfc45141b08ed665458be8c6285e7b85bd73a1",
                "sha256:fec866a0b59f372b7e776f2d7308511784dace622e0992a0b59ea3ccee0ae833"
            ],
            "markers": "python_full_version >= '3.6.1'",
            "version": "==1.8.2"
        },
        "pygments": {
            "hashes": [
                "sha256:b8e67fe6af78f492b3c4b3e2970c0624cbf08beb1e493b2c99b9fa1b67a20380",
                "sha256:f398865f7eb6874156579fdf36bc840a03cab64d1cde9e93d68f46a425ec52c6"
            ],
            "markers": "python_version >= '3.5'",
            "version": "==2.10.0"
        },
        "pyinquirer": {
            "hashes": [
                "sha256:c9a92d68d7727fbd886a7908c08fd9e9773e5dc211bf5cbf836ba90d366dee51"
            ],
            "index": "pypi",
            "version": "==1.0.3"
        },
        "pyperclip": {
            "hashes": [
                "sha256:105254a8b04934f0bc84e9c24eb360a591aaf6535c9def5f29d92af107a9bf57"
            ],
            "version": "==1.8.2"
        },
        "regex": {
            "hashes": [
                "sha256:0075fe4e2c2720a685fef0f863edd67740ff78c342cf20b2a79bc19388edf5db",
                "sha256:0621c90f28d17260b41838b22c81a79ff436141b322960eb49c7b3f91d1cbab6",
                "sha256:070336382ca92c16c45b4066c4ba9fa83fb0bd13d5553a82e07d344df8d58a84",
                "sha256:075b0fdbaea81afcac5a39a0d1bb91de887dd0d93bf692a5dd69c430e7fc58cb",
                "sha256:07e3755e0f070bc31567dfe447a02011bfa8444239b3e9e5cca6773a22133839",
                "sha256:0ed3465acf8c7c10aa2e0f3d9671da410ead63b38a77283ef464cbb64275df58",
                "sha256:17e095f7f96a4b9f24b93c2c915f31a5201a6316618d919b0593afb070a5270e",
                "sha256:1d85ca137756d62c8138c971453cafe64741adad1f6a7e63a22a5a8abdbd19fa",
                "sha256:20605bfad484e1341b2cbfea0708e4b211d233716604846baa54b94821f487cb",
                "sha256:23f93e74409c210de4de270d4bf88fb8ab736a7400f74210df63a93728cf70d6",
                "sha256:2bb7cae741de1aa03e3dd3a7d98c304871eb155921ca1f0d7cc11f5aade913fd",
                "sha256:2e3ff69ab203b54ce5c480c3ccbe959394ea5beef6bd5ad1785457df7acea92e",
                "sha256:30fe317332de0e50195665bc61a27d46e903d682f94042c36b3f88cb84bd7958",
                "sha256:3576e173e7b4f88f683b4de7db0c2af1b209bb48b2bf1c827a6f3564fad59a97",
                "sha256:35ed5714467fc606551db26f80ee5d6aa1f01185586a7bccd96f179c4b974a11",
                "sha256:41c66bd6750237a8ed23028a6c9173dc0c92dc24c473e771d3bfb9ee817700c3",
                "sha256:48b4f4810117a9072a5aa70f7fea5f86fa9efbe9a798312e0a05044bd707cc33",
                "sha256:4abf35e16f4b639daaf05a2602c1b1d47370e01babf9821306aa138924e3fe92",
                "sha256:4fba661a4966adbd2c3c08d3caad6822ecb6878f5456588e2475ae23a6e47929",
                "sha256:5e85dcfc5d0f374955015ae12c08365b565c6f1eaf36dd182476a4d8e5a1cdb7",
                "sha256:77f9d16f7970791f17ecce7e7f101548314ed1ee2583d4268601f30af3170856",
                "sha256:7ee36d5113b6506b97f45f2e8447cb9af146e60e3f527d93013d19f6d0405f3b",
                "sha256:7fab29411d75c2eb48070020a40f80255936d7c31357b086e5931c107d48306e",
                "sha256:85289c25f658e3260b00178757c87f033f3d4b3e40aa4abdd4dc875ff11a94fb",
                "sha256:886f459db10c0f9d17c87d6594e77be915f18d343ee138e68d259eb385f044a8",
                "sha256:897c539f0f3b2c3a715be651322bef2167de1cdc276b3f370ae81a3bda62df71",
                "sha256:8fbe1768feafd3d0156556677b8ff234c7bf94a8110e906b2d73506f577a3269",
                "sha256:9267e4fba27e6dd1008c4f2983cc548c98b4be4444e3e342db11296c0f45512f",
                "sha256:9486ebda015913909bc28763c6b92fcc3b5e5a67dee4674bceed112109f5dfb8",
                "sha256:956187ff49db7014ceb31e88fcacf4cf63371e6e44d209cf8816cd4a2d61e11a",
                "sha256:a56735c35a3704603d9d7b243ee06139f0837bcac2171d9ba1d638ce1df0742a",
                "sha256:ab1fea8832976ad0bebb11f652b692c328043057d35e9ebc78ab0a7a30cf9a70",
                "sha256:adf35d88d9cffc202e6046e4c32e1e11a1d0238b2fcf095c94f109e510ececea",
                "sha256:af23b9ca9a874ef0ec20e44467b8edd556c37b0f46f93abfa93752ea7c0e8d1e",
                "sha256:b3794cea825f101fe0df9af8a00f9fad8e119c91e39a28636b95ee2b45b6c2e5",
                "sha256:bb11c982a849dc22782210b01d0c1b98eb3696ce655d58a54180774e4880ac66",
                "sha256:be30cd315db0168063a1755fa20a31119da91afa51da2907553493516e165640",
                "sha256:c6238d30dcff141de076344cf7f52468de61729c2f70d776fce12f55fe8df790",
                "sha256:cb1e44d860345ab5d4f533b6c37565a22f403277f44c4d2d5e06c325da959883",
                "sha256:d4bfe3bc3976ccaeb4ae32f51e631964e2f0e85b2b752721b7a02de5ce3b7f27",
                "sha256:d8ee91e1c295beb5c132ebd78616814de26fedba6aa8687ea460c7f5eb289b72",
                "sha256:e3c00cb5c71da655e1e5161481455479b613d500dd1bd252aa01df4f037c641f",
                "sha256:e9cec3a62d146e8e122d159ab93ac32c988e2ec0dcb1e18e9e53ff2da4fbd30c",
                "sha256:ef4e53e2fdc997d91f5b682f81f7dc9661db9a437acce28745d765d251902d85",
                "sha256:f0148988af0182a0a4e5020e7c168014f2c55a16d11179610f7883dd48ac0ebe",
                "sha256:f20f9f430c33597887ba9bd76635476928e76cad2981643ca8be277b8e97aa96",
                "sha256:f5930d334c2f607711d54761956aedf8137f83f1b764b9640be21d25a976f3a4",
                "sha256:f6a28e87ba69f3a4f30d775b179aac55be1ce59f55799328a0d9b6df8f16b39d",
                "sha256:f9ee98d658a146cb6507be720a0ce1b44f2abef8fb43c2859791d91aace17cd5"
            ],
            "version": "==2021.11.2"
        },
        "simple-crypt": {
            "hashes": [
                "sha256:49462ab7ea4b080a8c10e362abfe35ecfa6dbe1e1c454ea36de7d2a71dce992f"
            ],
            "index": "pypi",
            "version": "==4.1.7"
        },
        "six": {
            "hashes": [
                "sha256:1e61c37477a1626458e36f7b1d82aa5c9b094fa4802892072e49de9c60c4c926",
                "sha256:8abb2f1d86890a2dfb989f9a77cfcfd3e47c2a354b01111771326f8aa26e0254"
            ],
            "markers": "python_version >= '2.7' and python_version not in '3.0, 3.1, 3.2, 3.3'",
            "version": "==1.16.0"
        },
        "tabulate": {
            "hashes": [
                "sha256:d7c013fe7abbc5e491394e10fa845f8f32fe54f8dc60c6622c6cf482d25d47e4",
                "sha256:eb1d13f25760052e8931f2ef80aaf6045a6cceb47514db8beab24cded16f13a7"
            ],
            "index": "pypi",
            "version": "==0.8.9"
        },
        "typing-extensions": {
            "hashes": [
                "sha256:49f75d16ff11f1cd258e1b988ccff82a3ca5570217d7ad8c5f48205dd99a677e",
                "sha256:d8226d10bc02a29bcc81df19a26e56a9647f8b0a6d4a83924139f4a8b01f17b7",
                "sha256:f1d25edafde516b146ecd0613dabcc61409817af4766fbbcfb8d1ad4ec441a34"
            ],
            "version": "==3.10.0.2"
        },
        "wcwidth": {
            "hashes": [
                "sha256:beb4802a9cebb9144e99086eff703a642a13d6a0052920003a230f3294bbe784",
                "sha256:c4d647b99872929fdb7bdcaa4fbe7f01413ed3d98077df798530e5b04f116c83"
            ],
            "version": "==0.2.5"
        }
    },
    "develop": {
        "argparse": {
            "hashes": [
                "sha256:62b089a55be1d8949cd2bc7e0df0bddb9e028faefc8c32038cc84862aefdd6e4",
                "sha256:c31647edb69fd3d465a847ea3157d37bed1f95f19760b11a47aa91c04b666314"
            ],
            "version": "==1.4.0"
        },
        "linecache2": {
            "hashes": [
                "sha256:4b26ff4e7110db76eeb6f5a7b64a82623839d595c2038eeda662f2a2db78e97c",
                "sha256:e78be9c0a0dfcbac712fe04fbf92b96cddae80b1b842f24248214c8496f006ef"
            ],
            "version": "==1.0.0"
        },
        "six": {
            "hashes": [
                "sha256:1e61c37477a1626458e36f7b1d82aa5c9b094fa4802892072e49de9c60c4c926",
                "sha256:8abb2f1d86890a2dfb989f9a77cfcfd3e47c2a354b01111771326f8aa26e0254"
            ],
            "markers": "python_version >= '2.7' and python_version not in '3.0, 3.1, 3.2, 3.3'",
            "version": "==1.16.0"
        },
        "traceback2": {
            "hashes": [
                "sha256:05acc67a09980c2ecfedd3423f7ae0104839eccb55fc645773e1caa0951c3030",
                "sha256:8253cebec4b19094d67cc5ed5af99bf1dba1285292226e98a31929f87a5d6b23"
            ],
            "version": "==1.4.0"
        },
        "unittest2": {
            "hashes": [
                "sha256:13f77d0875db6d9b435e1d4f41e74ad4cc2eb6e1d5c824996092b3430f088bb8",
                "sha256:22882a0e418c284e1f718a822b3b022944d53d2d908e1690b319a9d3eb2c0579"
            ],
            "index": "pypi",
            "version": "==1.1.0"
        }
    }
}
{
	"fileLocation": "",
	"configured": false
}

----------------------------------------------------------------------------------------------------------------------------------

import itertools
import threading
import time
import sys

done = False
#here is the animation
def animate():
    for c in itertools.cycle(['|', '/', '-', '\\']):
        if done:
            break
        sys.stdout.write('\rloading ' + c)
        sys.stdout.flush()
        time.sleep(0.5)
    sys.stdout.write('\rDone!     \n')

t = threading.Thread(target=animate)
t.start()

#long process here
time.sleep(0.5)
done = True
time.sleep(0.6)
print("Asasdfsdafd")import itertools

----------------------------------------------------------------------------------------------------------------------------------

import threading
import time
import sys

class Animate:
	AnimationType = "encrypt" or "decrypt"
	def __init__(self) -> None:
		self.done = False

	def animate(self, text:str)->None:
		for c in itertools.cycle([".  ", ".. ", "...", "   "]):
			if self.done:
				self.done = False
				break
			sys.stdout.write(f"\r{text}ing {c}")
			sys.stdout.flush()
			time.sleep(0.5)
		sys.stdout.write(f"\r{text}ed!     \n")


	def startAnimation(self, animationType:AnimationType)->None:
		t = threading.Thread(target=self.animate, args=[animationType])
		t.start()

	def stopAnimation(self)->None:
		self.done = True
		time.sleep(0.8)a

----------------------------------------------------------------------------------------------------------------------------------

from PyInquirer.utils import print_json
from simplecrypt import encrypt, decrypt, DecryptionException
from userInput import chooseFrom, confirm, getKEY, showActionList, getPassword
from tabulate import tabulate
import pswdManager
import json
import os
import animation

KEY = ""
fileLocation = os.path.join(os.path.expanduser("~"), "pswds.bin")
pswdsBackup = pswdManager.PasswordManager()
pswds = pswdManager.PasswordManager()
animate = animation.Animate()


def encryptPswdData(passwords:dict)->bool:
	# print("\nEncrypting...")
	passwords_json = json.dumps(passwords)
	animate.startAnimation("Encrypt")
	encryptedPswds = encrypt(KEY, passwords_json)
	animate.stopAnimation()
	try:
		with open(fileLocation, "wb") as f:
			f.write(encryptedPswds)
	except Exception as e:
		print("There was some error while encrypting the data")


def decryptPswdData()->dict:
	# print("\nDecrypting...")
	global pswdsBackup, KEY
	encryptedPswds = ""

	try:
		with open(fileLocation, "rb") as f:
			encryptedPswds = f.readline()
		animate.startAnimation("Decrypt")
		decryptedPswds = decrypt(KEY, encryptedPswds)
		animate.stopAnimation()
		decryptedPswds_str = decryptedPswds.decode("utf-8")
		decryptedPswds_json = json.loads(decryptedPswds_str)
		pswds.passwordsDecrypted = True
		if len(list(decryptedPswds_json.keys())) == 0:
			pswds.setPasswords({})
			pswdsBackup.setPasswords({})
			return {
				"status": "successful",
				"decryptedPswds": {}
			}
		else:
			pswds.setPasswords(decryptedPswds_json)
			pswdsBackup.setPasswords(decryptedPswds_json.copy())
			return {
				"status": "successful",
				"decryptedPswds": decryptedPswds_json
			}

	except FileNotFoundError:
		print("Password file not found... making one")
		encryptPswdData({})
		print("MADE THE PASSWORDS FILE")
		pswds.passwordsDecrypted = True
		return {
			"status": "successful",
			"decryptedPswds": {}
		}
	except DecryptionException as e: 
		errMsg = str(e)
		if errMsg == "Bad password or corrupt / modified data.":
			return {
				"status": "error",
				"msg": errMsg
			}
		elif errMsg == "Passwords File Not found":
			encryptPswdData({})
			print("MADE THE PASSWORD FILE")
			pswds.passwordsDecrypted = True
			return {
				"status": "successful",
				"decryptedPswds": {}
			}
		else:
			print("There was some problem while decrypting the password")
			print("ERROR -> ")
			print(e)


def listPswds():
	if pswds.countPassword() == 0:
		print("\nTHERE ARE NO PASSWORDS SAVED")
		return False
	accountNames = [pswd.capitalize() for pswd in list(pswds.getPasswords().keys())]
	accountPasswords = []
	passwords = pswds.getPasswords()
	for accName in accountNames:
		pswd = passwords[accName.lower()]
		accountPasswords.append(pswd)
	print()
	print(
		tabulate(
			{
				"ACCOUNT": accountNames, 
				"PASSWORDS": accountPasswords
			}, 
			headers=["ACCOUNT", "PASSWORDS"]
		)
	)
	print()


def addNewPswd():
	if pswds.passwordsDecrypted == False:
		decryptPswdData()
	accountName = input("ACCOUNT: ").lower().strip()
	if accountExists(accountName):
		if not confirm("The account alredy exists, do you want to overide it"):
			return False
	accountPass = getPassword()
	pswds.addPassword(accountName, accountPass)


def writeChanges():
	passwords = pswds.getPasswords()
	passwordsBackup = pswdsBackup.getPasswords()

	print(passwords)
	print(passwordsBackup)

	if (pswds.countPassword() == 0) or (passwords == passwordsBackup):
		print("\nTHERE ARE NO NEW PASSWORDS TO SAVE")
		return False
	
	encryptPswdData(passwords)
	pswdsBackup.setPasswords(passwords.copy())


def discardChanges():
	if confirm("Do you want to continue all the unsaved changes will be lost"):
		pswds.setPasswords(pswdsBackup.getPasswords().copy())
		print("\nNEW PASSWORDS DISCARDED")


def askUserForKey():
	global KEY
	KEY = getKEY()


def accountExists(account, showInfoMsg=False)->bool:
	if account.lower() in pswds.getPasswords():
		return True
	if showInfoMsg:
		print("\nACCOUNT NOT FOUND")
		print("    1) Check whether account name is spelled correctly")
		print("    2) Check the account exists or not")
	return False


def chooseAccount(msg)->str or bool:
	existingAccounts = list(pswds.getPasswords().keys())
	choosenAccountName = chooseFrom(existingAccounts, msg)
	if choosenAccountName == "EXIT":
		return False
	return choosenAccountName


def deleteAccount():
	account = chooseAccount("Enter the account you want to remove")
	if account:
		ans = confirm(f"Are you sure you want to remove {account}'s password:")
		if ans:
			pswds.delAccount(account)
			print("The account was removed")


def renameAccount():
	oldAccountName = chooseAccount("Enter the account name you want to change")
	if oldAccountName:
		if accountExists(oldAccountName, True):
			newAccountname = input("Enter the new account name: ")
			pswds.renameAccountName(oldAccountName, newAccountname)


def changePassword():
	account = chooseAccount("Enter the account name you want to change")
	if account:
		newPassword = getPassword()
		pswds.addPassword(account, newPassword)
		print(f"\nPassword for {account} changed successfully!")


def checkFileExists():
	
	pass


def changeKEY():
	global pswdsBackup
	msg = "In order to change the KEY all the changes (if any) will be saved"
	if confirm(msg):
		os.remove(fileLocation)
		askUserForKey()
		passwords = pswds.getPasswords()
		encryptPswdData(passwords)
		pswdsBackup.setPasswords(passwords.copy())
	else:
		return False
		

if __name__ == "__main__":
	while True:
		askUserForKey()
		res = decryptPswdData()
		if res["status"] == "successful":
			break
		else:
			print(res["msg"])
	exit = False

	def endLoop():
		global exit, pswds, pswdsBackup
		if pswds.getPasswords() != pswdsBackup.getPasswords():
			if not confirm("All the unsaved changes will be lost"):
				return False
		exit=True

	actions = {
		"List passwords": listPswds,
		"Add new password": addNewPswd,
		"Write changes": writeChanges,
		"Discard Changes": discardChanges,
		"Delete account": deleteAccount,
		"Rename account": renameAccount,
		"Change existing password": changePassword,
		"Change KEY": changeKEY,
		"Exit": endLoop,
	}

	while not exit:
		print()
		choice = showActionList()
		actions[choice]()
----------------------------------------------------------------------------------------------------------------------------------

import json
from userInput import confirm, getKEY, showActionList, getPassword
from simplecrypt import encrypt, decrypt, DecryptionException

class PasswordManager:
	def __init__(self) -> None:
		self.passwords:dict = {}
		self.passwordsDecrypted:bool = False
		
	def countPassword(self)->int:
		return len(list(self.passwords.keys()))


	def getPasswords(self)->dict:
		return self.passwords
	

	def setPasswords(self, newPasswords:dict)->bool:
		self.passwords = newPasswords
		return True


	def delAccount(self, accountName:str)->bool:
		del self.passwords[accountName]
		return True


	def renameAccountName(self, oldAccountName:str, newAccountName:str)->bool:
		oldAccountName = oldAccountName.lower()
		newAccountName = newAccountName.lower()
		password = self.passwords[oldAccountName]
		del self.passwords[oldAccountName]
		self.passwords[newAccountName] = password

	# This method is used for both adding passwords and changing it
	# As the logic is the same
	def addPassword(self, account:str, password:str):
		self.passwords[account] = password

----------------------------------------------------------------------------------------------------------------------------------

1) Scenario 
    User Decrypts the passwords
    Makes changes to the passwords
    Chooses to decrypt again -> by this the new changed passwords can be resetted

    Possible solution
        Add a variable to check whether the passwords are decrypted or not
        and ignore/prevent the user from doing it again.

2) Remove the ? before the password file by customizing the custom_input_2 in userInput.py
and removing the question wala some property from the object

3) You have to remove pycrypto and pycryptodome and then install pycryptodome again
for the code to work. -> make an installation script which is ran once in the beginningfrom __future__ import print_function, unicode_literals
from pprint import pprint
from PyInquirer import prompt, print_json, style_from_dict, Separator
from examples import custom_style_1, custom_style_2

----------------------------------------------------------------------------------------------------------------------------------

def getKEY()->str:
	questions = [
		{
			"type": "password",
			"message": "Enter KEY:",
			"name": "KEY"
		}
	]
	answers = prompt(questions, style=custom_style_2)
	KEY = answers["KEY"]
	return KEY


def getPassword()->str:
	questions = [
		{
			"type": "password",
			"message": "Enter password:",
			"name": "password"
		}
	]
	answers = prompt(questions, style=custom_style_2)
	password = answers["password"]
	return password


def confirm(message)->bool:
	questions = [
			{
					"type": "confirm",
					"message": message,
					"name": "continue",
					"default": True,
			}
	]
	answers = prompt(questions, style=custom_style_1)
	return answers["continue"]


def chooseFrom(choices:list, message:str)->str:
	choices.append("EXIT")
	options = [
		{
			"type": "list",
			"name": "account",
			"message": message,
			"choices": choices,
		}
	]
	choice = prompt(options, style=custom_style_2)
	choice = choice["account"]
	return choice


def showActionList():
	questions = [
		{
			"type": "list",
			"name": "choice",
			"message": "Action to perform",
			"choices": [
				"List passwords",
				"Add new password",
				"Change existing password",
				"Delete account",
				"Rename account",
				"Write changes",
				"Discard Changes",
				"Change KEY",
				"Exit",
			]
		}
	]
	choice = prompt(questions, style=custom_style_2)
	choice = choice["choice"]
	return choicea

    _��a�  �                   @   s2   d dl Z d dlZd dlZd dlZG dd� d�ZdS )�    Nc                   @   sP   e Zd ZdpdZdd�dd�Zedd�dd	�Zedd
�dd�Zdd�d
d�ZdS )�Animate�encrypt�decryptN)�returnc                 C   s
   d| _ d S )NF��done��self� r
   �@/home/uttkarsh/Programming/Python/Practice/PswdMngr/animation.py�__init__   s    zAnimate.__init__)�textr   c                 C   s~   t �g d��D ]@}| jr"d| _ qPtj�d|� d|� �� tj��  t�d� qtj�d|� d�� tj�d� tj��  d S )N)z.  z.. z...F�
zing g      �?zed!     z
     )	�	itertools�cycler   �sys�stdout�write�flush�time�sleep)r	   r
   �cr
   r
   r   �animate   s    
zAnimate.animate)�
animationTyper   c                 C   s   t j| j|gd�}|��  d S )N)�target�args)�	threading�Threadr   �start)r	   r   �tr
   r
   r   �startAnimation   s    zAnimate.startAnimationc                 C   s
   d| _ d S )NTr   r   r
   r
   r   �
stopAnimation   s    zAnimate.stopAnimation)	�__name__�
__module__�__qualname__Z
AnimationTyper   �strr   r    r!   r
   r
   r
   r   r      s
   
r   )r   r   r   r   r   r
   r
   r
   r   �<module>   s   Archive/
__pycache__/
*.bin
[[source]]
url = "https://pypi.org/simple"
verify_ssl = true
name = "pypi"

[packages]
simple-crypt = "*"
pycryptodome = "*"
getpass4 = "*"
tabulate = "*"
examples = "*"
prompt = "*"
pyinquirer = "*"

[dev-packages]
unittest2 = "*"

[requires]
python_version = "3.9"
a

    ���a!  �                   @   sF   d dl Z d dlmZmZmZmZ d dlmZmZm	Z	 G dd� d�Z
dS )�    N)�confirm�getKEY�showActionList�getPassword)�encrypt�decrypt�DecryptionExceptionc                   @   sx   e Zd Zdd�dd�Zed�dd�Zed�dd�Zeed	�d
d�Z	e
ed�d
d�Ze
e
ed�dd�Ze
e
d�dd�Z
dS )�PasswordManagerN)�returnc                 C   s   i | _ d| _d S )NF)�	passwords�passwordsDecrypted��self� r   �B/home/uttkarsh/Programming/Python/Practice/PswdMngr/pswdManager.py�__init__   s    zPasswordManager.__init__c                 C   s   t t| j�� ��S �N)�len�listr   �keysr
   r   r   r   �
countPassword
   s    zPasswordManager.countPasswordc                 C   s   | j S r   �r   r
   r   r   r   �getPasswords   s    zPasswordManager.getPasswords)�newPasswordsr
   c                 C   s
   || _ dS �NTr   )r   r   r   r   r   �setPasswords   s    zPasswordManager.setPasswords)�accountNamer
   c                 C   s   | j |= dS r   r   )r   r   r   r   r   �
delAccount   s    zPasswordManager.delAccount)�oldAccountName�newAccountNamer
   c                 C   s0   |� � }|� � }| j| }| j|= || j|< d S r   )�lowerr   )r   r   r   �passwordr   r   r   �renameAccountName   s
    
z!PasswordManager.renameAccountName)�accountr!   c                 C   s   || j |< d S r   r   )r   r#   r!   r   r   r   �addPassword%   s    zPasswordManager.addPassword)�__name__�
__module__�__qualname__r   �intr   �dictr   �boolr   �strr   r"   r$   r   r   r   r   r	      s   	r	   )�json�	userInputr   r   r   r   �simplecryptr   r   r   r	   r   r   r   r   �<module>   s   from __future__ import with_statement

----------------------------------------------------------------------------------------------------------------------------------

from PyInquirer.utils import print_json
from simplecrypt import encrypt, decrypt, DecryptionException
from userInput import confirm, getKEY, showActionList, getPassword
from tabulate import tabulate
import json
import os

KEY = "uttkarsh"
fileDirectory = ""
fileName = "pswds.bin"
filePath = os.path.join(fileDirectory, fileName)
pswds = {}
pswds_backup = {}


def passwordCount():
  return len(list(pswds.keys()))


def setPswds(passwords:dict):
  global pswds
  pswds = passwords


def encryptPswdData(passwords:object)->bool:
  print("-*-*-*-*-*--ENCRYPTING--*-*-*-*-*-")
  passwords_json = json.dumps(passwords)
  encryptedPswds = encrypt(KEY, passwords_json)
  try:
    with open(filePath, "wb+") as f:
      f.write(encryptedPswds)
  except Exception as e:
    print("There was some error while encrypting the data")


def decryptPswdData()->dict:
  global pswds, pswdsBackup
  encryptedPswds = ""

  try:
    with open(filePath, "rb") as f:
      encryptedPswds = f.readline()
    
    decryptedPswds = decrypt(KEY, encryptedPswds)
    decryptedPswds_str = decryptedPswds.decode("utf-8")

    if len(decryptedPswds_str) == 0:
      pswds = {}
      pswdsBackup={}
      return False
    decryptedPswds_json = json.loads(decryptedPswds_str)
    if len(list(decryptedPswds_json.keys())) == 0:
      pswds = {}
      pswdsBackup={}
    else:
      pswds = decryptedPswds_json
      pswdsBackup = decryptedPswds_json
    return {
      "status": "successful",
      "decryptedPswds": decryptedPswds_json
    }
  except FileNotFoundError:
    return {
      "status": "error",
      "msg": "Passwords File Not found"
    }
  except DecryptionException: #occours when the headers arent set properly in the file
    # setPswds({})
    encryptPswdData({})
    return {
      "status": "successful",
      "decryptedPswds": {}
    }


def listPswds():
  if passwordCount() == 0:
    result = decryptPswdData()
    if result["status"] == "error":
      print(f"\n {result['msg']} \n")
      return False

  if passwordCount() == 0:
    print("\nTHERE ARE NO PASSWORDS SAVED\n")
    return False

  accountNames = [pswd.capitalize() for pswd in list(pswds.keys())]
  accountPasswords = []
  for accName in accountNames:
    pswd = pswds[accName.lower()]
    accountPasswords.append(pswd)
  print()
  print(
    tabulate(
      {
        "ACCOUNT": accountNames, 
        "PASSWORDS": accountPasswords
      }, 
      headers=["ACCOUNT", "PASSWORDS"]
    )
  )
  print()


def addNewPswd():
  if passwordCount() == 0:
    result = decryptPswdData()
    if result["status"] == "error":
      if result["msg"] == "Passwords File Not found":
        open(filePath, "w").close()
      else:
        print(result["msg"])
        return False

  accountName = input("ACCOUNT: ").lower()
  accountPass = getPassword()
  if accountName in pswds:
    if confirm("The account alredy exists, do you want to overide it (Y/n)"):
      pswds[accountName] = accountPass
  else:
    pswds[accountName] = accountPass


def writeChanges():
  global pswds_backup

  print(f"pswds_backup = {json.dumps(pswds_backup, indent=2)}")
  print(f"pswds = {json.dumps(pswds, indent=2)}")
  if (passwordCount()==0) or (pswds_backup==pswds):
    print("\nTHERE ARE NO NEW PASSWORDS TO SAVE\n\n")
    return False
  pswds_backup = pswds
  encryptPswdData(pswds)


def discardChanges():
  global pswds
  pswds = pswds_backup
  print("\nNEW PASSWORDS DISCARDED\n\n")


def askUserForKey()->str:
  global KEY
  KEY = getKEY()
  return KEY


def accountExists(account)->bool:
  if account.lower() not in pswds:
    print("ACCOUNT NOT FOUND")
    print("    1) Check whether account name is spelled correctly")
    print("    2) Check the account name exists or not")
    return False
  return True


def deletePassword():
  account = input("Enter the account you want to remove: ")
  if not accountExists(account):
    return False
  ans = confirm(f"Are you sure you want to remove {account}'s password:")
  if ans:
    del pswds[account]
    print("The account was removed")


def checkFileExists():
  if not os.path.exists(filePath):
    encryptPswdData({})


def changePassword():
  account = input("Enter the account you want to change the password for: ")
  newPswd = getPassword()
  if accountExists(account):
    pswds[account] = newPswd
    print(f"Password for {account} changed successfully!")


if __name__ == "__main__":
  askUserForKey()
  checkFileExists()
  exit = False

  def endLoop():
    global exit
    exit=True

  actions = {
    "List passwords": listPswds,
    "Add new password": addNewPswd,
    "Re-enter KEY": askUserForKey,
    "Exit": endLoop,
    "Write changes": writeChanges,
    "Discard changes": discardChanges,
    "Delete old password": deletePassword,
  }

  while not exit:
    choice = showActionList()
    actions[choice]()